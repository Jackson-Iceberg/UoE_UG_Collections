
I had a total of 12 tests and it had 82.6% coverage. The minimization criteria is based on the class and its methods. If it's a small class like Option class, it only needs one test to cover the entire class methods. Since some other classes need to invoke methods in the Option class, the test for the Option class only needs to fill in the uncovered parts. For the OptionMap class, I have 6 tests because there are many methods in this class. Therefore, combining some similar methods together and testing these methods in one test minimizes them. Also, due to the characteristics of the methods, for example, the store method and the isOptionValid method. The store method will invoke the isOptionValid method, so it can be combined as one test to reduce multiple tests. Also, all getMethods and setMethods can be tested together because of their similarity, e.g.: getOption method, getShortcut method and getOptionByNameOrShortcut method.


For the Parser class, I have 5 tests because there are many methods in this class and some of them are complex. Some of the methods have invoke relationships, so combining them together can help with minimization. For example: addOption method, optionExists method, shortcutExists method, optionOrShortcutExists method. All getMethods can be combined together because they have similarities. For example: getInteger method, getBoolean method, getString method, getCharacter. In addition, setShortcut method and replace method can both change the value of shortcut and the value of Option, which can be combined together because of similar functions. In addition, the parse method is a big method that contains many branches, so this method needs a specific test to check to avoid confusion. And it also needs an additional test to fill in some uncovered branches.

